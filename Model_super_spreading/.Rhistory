betaX = 0.05
gammaX = 10
dnbinom(1, betaX, 1/(1 + gammaX))
rnbinom(1, betaX, 1/(1 + gammaX))
help("rnbinom")
rpois(1, gammaX)
rpois(2, gammaX)
rnbinom(3, betaX, 1/(1 + gammaX))
simulate_branching_ss = function(num_days, shape_gamma, scale_gamma, alphaX, betaX, gammaX) {
'Simulate an epidemic with Superspreading events
prop_ss = Proportion of superspreading days
magnitude_ss = increased rate of superspreading event'
#Set up
total_infecteds = vector('numeric', num_days)
nsse_infecteds = vector('numeric', num_days)
sse_infecteds = vector('numeric', num_days)
total_infecteds[1] = 2
nsse_infecteds[1] = 2
sse_infecteds[1] = 0
#Infectiousness (Discrete gamma) - I.e 'Infectiousness Pressure' - Sum of all people
#Explanation: Gamma is a continuous function so integrate over the density at that point in time (today - previous day)
prob_infect = pgamma(c(1:num_days), shape = shape_gamma, scale = scale_gamma) - pgamma(c(0:(num_days-1)), shape = shape_gamma, scale = scale_gamma)
#Days of Infection Spreading
for (t in 2:num_days) {
#Regular infecteds (tot_rate = lambda) fix notation
lambda_t = sum(nsse_infecteds[1:(t-1)]*rev(prob_infect[1:(t-1)])) #?Why is it the reversed probability - given the way prob_infect is written
tot_rate = alphaX*lambda_t #Product of infecteds & their probablilty of infection along the gamma dist at that point in time
nsse_infecteds[t] = rpois(1, tot_rate) #Assuming number of cases each day follows a poisson distribution. Causes jumps in data
#Super-spreaders
n_t = rpois(1, betaX*lambda_t) #Number of super-spreading events (beta)
if (n_t > 0){
sse_infecteds[t] = dnbinom(1, bX*lambda_t, 1/(1 + gammaX)) #z_t: Total infecteds due to super-spreading event - num of events x Num individuals
}
total_infecteds[t] = nsse_infecteds[t] + sse_infecteds[t]
}
total_infecteds
}
#********
#*Implement
num_days = 50
#lambda params
shape_gamma = 6
scale_gamma = 1
#params
alphaX = 2 #Without ss event, ~r0.
betaX = 0.05
gammaX = 10
#Epidemic data
sim_data = simulate_branching_ss(num_days, shape_gamma, scale_gamma, alphaX, betaX, gammaX)
plot.ts(sim_data, ylab = 'Daily Infections count', main = 'Daily Infections count')
simulate_branching_ss = function(num_days, shape_gamma, scale_gamma, alphaX, betaX, gammaX) {
'Simulate an epidemic with Superspreading events
prop_ss = Proportion of superspreading days
magnitude_ss = increased rate of superspreading event'
#Set up
total_infecteds = vector('numeric', num_days)
nsse_infecteds = vector('numeric', num_days)
sse_infecteds = vector('numeric', num_days)
total_infecteds[1] = 2
nsse_infecteds[1] = 2
sse_infecteds[1] = 0
#Infectiousness (Discrete gamma) - I.e 'Infectiousness Pressure' - Sum of all people
#Explanation: Gamma is a continuous function so integrate over the density at that point in time (today - previous day)
prob_infect = pgamma(c(1:num_days), shape = shape_gamma, scale = scale_gamma) - pgamma(c(0:(num_days-1)), shape = shape_gamma, scale = scale_gamma)
#Days of Infection Spreading
for (t in 2:num_days) {
#Regular infecteds (tot_rate = lambda) fix notation
lambda_t = sum(nsse_infecteds[1:(t-1)]*rev(prob_infect[1:(t-1)])) #?Why is it the reversed probability - given the way prob_infect is written
tot_rate = alphaX*lambda_t #Product of infecteds & their probablilty of infection along the gamma dist at that point in time
nsse_infecteds[t] = rpois(1, tot_rate) #Assuming number of cases each day follows a poisson distribution. Causes jumps in data
#Super-spreaders
n_t = rpois(1, betaX*lambda_t) #Number of super-spreading events (beta)
if (n_t > 0){
sse_infecteds[t] = dnbinom(1, betaX*lambda_t, 1/(1 + gammaX)) #z_t: Total infecteds due to super-spreading event - num of events x Num individuals
}
total_infecteds[t] = nsse_infecteds[t] + sse_infecteds[t]
}
total_infecteds
}
#********
#*Implement
num_days = 50
#lambda params
shape_gamma = 6
scale_gamma = 1
#params
alphaX = 2 #Without ss event, ~r0.
betaX = 0.05
gammaX = 10
#Epidemic data
sim_data = simulate_branching_ss(num_days, shape_gamma, scale_gamma, alphaX, betaX, gammaX)
plot.ts(sim_data, ylab = 'Daily Infections count', main = 'Daily Infections count')
sim_data
#params
alphaX = 2 #Without ss event, ~r0.
betaX = 0.2
gammaX = 10
#Epidemic data
sim_data = simulate_branching_ss(num_days, shape_gamma, scale_gamma, alphaX, betaX, gammaX)
plot.ts(sim_data, ylab = 'Daily Infections count', main = 'Daily Infections count')
#********************************************************************
#MCMC Super-spreading
mcmc_super_spreading <- function(data, n, sigma,  x0 = 1) { #burn_in = 2500
'Returns mcmc samples of alpha & acceptance rate'
#Set up
alpha_vec <- vector('numeric', n); beta_vec <- vector('numeric', n)
gamma_vec <- vector('numeric', n)
alpha_vec[1] <- x0; beta_vec[1] <- x0; gamma_vec[1] <- x0
count_accept1 = 0; count_reject1 = 0; count_accept2 = 0
count_reject2 = 0; count_accept3 = 0; count_reject3 = 0
#MCMC chain
for(i in 2:n) {
#******************************************************
#alpha
alpha_dash <- alpha_vec[i-1] + rnorm(1, sd = sigma)
#cat("alpha dash: ", alpha_dash, "\n")
if(alpha_dash < 0){
alpha_dash = abs(alpha_dash)
}
#log alpha
logl_new = log_like_ss_lse(data, alpha_dash, beta_vec[i-1], gamma_vec[i-1])
logl_prev = log_like_ss_lse(data, alpha_vec[i-1], beta_vec[i-1], gamma_vec[i-1])
prior1 = dgamma(alpha_dash, shape = 1, scale = 1, log = TRUE)
prior2 = dgamma(alpha_vec[i-1], shape = 1, scale = 1, log = TRUE)
log_accept_prob = logl_new - logl_prev #+ prior1 - prior2
if(!(is.na(log_accept_prob)) && log(runif(1)) < log_accept_prob) {
alpha_vec[i] <- alpha_dash
count_accept1 = count_accept1 + 1
} else {
alpha_vec[i] <- alpha_vec[i-1]
count_reject1 = count_reject1 + 1
}
#Adaptive MC
#if (i == burn_in){
#  sigma1 = var(alpha_vec[2:i])*(2.38^2)
#print('Burn in reached')
#}
#************************************************************************
#beta
beta_dash <- beta_vec[i-1] + rnorm(1, sd = sigma)
#cat("Beta dash: ", beta_dash, "\n")
if(beta_dash < 0){
beta_dash = abs(beta_dash)
}
logl_new = log_like_ss_lse(data, alpha_vec[i], beta_dash, gamma_vec[i-1])
logl_prev = log_like_ss_lse(data, alpha_vec[i], beta_vec[i-1], gamma_vec[i-1])
prior1 = dgamma(beta_dash, shape = 1, scale = 1, log = TRUE)
prior2 = dgamma(beta_vec[i-1], shape = 1, scale = 1, log = TRUE)
log_accept_prob = logl_new - logl_prev #+ prior1 - prior2
if(!(is.na(log_accept_prob)) && log(runif(1)) < log_accept_prob) {
beta_vec[i] <- beta_dash
count_accept2 = count_accept2 + 1
} else {
beta_vec[i] <- beta_vec[i-1]
count_reject2 = count_reject2 + 1
}
#Adaptive MC
#if (i == burn_in){
#  sigma2 = var(beta_vec[2:i])*(2.38^2)
#}
#************************************************************************
#gamma
gamma_dash <- gamma_vec[i-1] + rnorm(1, sd = sigma)
if(gamma_dash < 0){
gamma_dash = abs(gamma_dash)
}
#Acceptance Probability
logl_new = log_like_ss_lse(data, alpha_vec[i], beta_vec[i], gamma_dash)
logl_prev = log_like_ss_lse(data, alpha_vec[i], beta_vec[i], gamma_vec[i-1])
prior1 = dgamma(gamma_dash, shape = 1, scale = 1, log = TRUE)
prior2 = dgamma(gamma_vec[i-1], shape = 1, scale = 1, log = TRUE)
log_accept_prob = logl_new - logl_prev #+ prior1 - prior2
#print
#cat("logl_new: ", logl_new, "\n")
#cat("logl_prev: ", logl_prev, "\n")
#cat("prior1: ", prior1, "\n")
#cat("prior2: ", prior2, "\n")
#cat("log_accept_prob: ", log_accept_prob, "\n")
#cat("log(U[i]): ", log(U[i]), "\n")
if(!(is.na(log_accept_prob)) && log(runif(1)) < log_accept_prob) {
gamma_vec[i] <- gamma_dash
count_accept3 = count_accept3 + 1
} else {
gamma_vec[i] <- gamma_vec[i-1]
count_reject3 = count_reject3 + 1
}
}
#Final stats
#alpha
total_iters1 = count_accept1 + count_reject1
accept_rate1 = 100*(count_accept1/(count_accept1+count_reject1))
num_samples1 = count_accept1
print("Acceptance rate1 = ")
print(accept_rate1)
#beta
total_iters2 = count_accept2 + count_reject2
accept_rate2 = 100*(count_accept2/(count_accept2+count_reject2))
num_samples2 = count_accept2
print("Acceptance rate2 = ")
print(accept_rate2)
#gamma
total_iters3 = count_accept3 + count_reject3
accept_rate3 = 100*(count_accept3/(count_accept3+count_reject3))
num_samples3 = count_accept3
print("Acceptance rate3 = ")
print(accept_rate3)
#Burn-in
#alpha_vec = alpha_vec[burn_in:n]
#beta_vec = beta_vec[burn_in:n]
#gamma_vec = gamma_vec[burn_in:n]
#Return alpha, acceptance rate
return(list(alpha_vec, beta_vec, gamma_vec,
accept_rate1, num_samples1, sigma,
accept_rate2, num_samples2, sigma,
accept_rate3, num_samples3, sigma))
}
#Setup
setwd("~/GitHub/epidemic_modelling/Model_super_spreading")
source("functions.R")
source("functions.R")
#Time
n = 1000
start_time = Sys.time()
print('Start time:')
print(start_time)
sigma = 1
mcmc_params_ad = mcmc_super_spreading(data2, n, sigma)
end_time = Sys.time()
time_elap = end_time - start_time
print('Time elapsed:')
print(time_elap)
#Extract params
alpha_mcmc = mcmc_params_ad[1]
alpha_mcmc = unlist(alpha_mcmc)
beta_mcmc = mcmc_params_ad[2]
beta_mcmc = unlist(beta_mcmc)
gamma_mcmc = mcmc_params_ad[3]
gamma_mcmc = unlist(gamma_mcmc)
#Plot
file_name = 'ss_mcmc_22_10_21_I'
folder_dir_ad = './Results/super_spreading_events/ss_mcmc_22_10_21_I' #Use date automate
plot_mcmc_super_spreading(sim_data, mcmc_vector1, mcmc_vector2, mcmc_vector3, alpha_true, betaX, gammaX, file_name, folder_dir_ad)
n = 1000
start_time = Sys.time()
print('Start time:')
print(start_time)
sigma = 1
mcmc_params_ad = mcmc_super_spreading(sim_data, n, sigma)
end_time = Sys.time()
time_elap = end_time - start_time
print('Time elapsed:')
print(time_elap)
#Extract params
alpha_mcmc = mcmc_params_ad[1]
alpha_mcmc = unlist(alpha_mcmc)
beta_mcmc = mcmc_params_ad[2]
beta_mcmc = unlist(beta_mcmc)
gamma_mcmc = mcmc_params_ad[3]
gamma_mcmc = unlist(gamma_mcmc)
#Plot
file_name = 'ss_mcmc_22_10_21_I'
folder_dir_ad = './Results/super_spreading_events/ss_mcmc_22_10_21_I' #Use date automate
plot_mcmc_super_spreading(sim_data, mcmc_vector1, mcmc_vector2, mcmc_vector3, alphaX, betaX, gammaX, file_name, folder_dir_ad)
source("functions.R")
plot.ts(sim_data)
plot_mcmc_super_spreading(sim_data, mcmc_vector1, mcmc_vector2, mcmc_vector3, alphaX, betaX, gammaX, file_name, folder_dir_ad)
./Results
folder_dir_ad = 'Results/super_spreading_events/ss_mcmc_22_10_21_I' #Use date automate
plot_mcmc_super_spreading(sim_data, mcmc_vector1, mcmc_vector2, mcmc_vector3, alphaX, betaX, gammaX, file_name, folder_dir_ad)
folder_dir_ad = 'Results/super_spreading_events/ss_mcmc_22_10_21_I' #Use date automate
plot_mcmc_super_spreading(sim_data, mcmc_vector1, mcmc_vector2, mcmc_vector3, alphaX, betaX, gammaX, file_name, folder_dir_ad)
plot_mcmc_super_spreading(sim_data, alpha_mcmc, beta_mcmc, gamma_mcmc, alphaX, betaX, gammaX, file_name, folder_dir_ad)
plot_mcmc_super_spreading_to_screen(sim_data, alpha_mcmc, beta_mcmc, gamma_mcmc, alphaX, betaX, gammaX, file_name, folder_dir_ad)
source('functions')
source("functions")
source("functions")
plot_mcmc_super_spreading_to_screen(sim_data, alpha_mcmc, beta_mcmc, gamma_mcmc, alphaX, betaX, gammaX, file_name, folder_dir_ad)
plot_mcmc_super_spreading_to_screen <- function(sim_data, mcmc_vector1, mcmc_vector2, mcmc_vector3, alpha_true, betaX, gammaX, file_name, folder_dir_ad) {
#Folder save
#ifelse(!dir.exists(file.path(folder_dir_ad)), dir.create(file.path(folder_dir_ad)), FALSE)
#pdf(paste(folder_dir_ad, "/", file_name, alpha_true, ".pdf", sep=""))
#i. Epidemic data
plot.ts(sim_data, ylab = 'Daily Infections count', main = 'Daily Infections count')
#i. MCMC chain
plot.ts(mcmc_vector1, ylab = 'alpha', main = paste("MCMC Results. Alpha - Super spreading model, true alpha = ", alpha_true))
#ii. Mean
#Plot mean
alpha_mean = cumsum(mcmc_vector1)/seq_along(mcmc_vector1)
plot(seq_along(alpha_mean), alpha_mean, xlab = 'Time', ylab = 'alpha', main = paste("Mean of alpha MCMC chain, True alpha = ",alpha_true))
#Histogram
#hist1 = hist(mcmc_vector, prob = TRUE)
#print(hist1)
#Hist
hist2 <- hist(mcmc_vector1, breaks = 80)
hist2$counts <- hist2$counts/sum(hist2$counts)
hist3 = plot(hist2, xlab = 'alpha', ylab = 'Density',
main = 'Empirical density of alpha - MCMC chain')
print(hist3)
#**************************************************
#2. beta
#i. MCMC chain
plot.ts(mcmc_vector2, ylab = 'beta', main = paste("MCMC Results; beta - Super spreading model, true beta = ", betaX))
#print(plot1)
#ii. Mean
#Plot mean
beta_mean = cumsum(mcmc_vector2)/seq_along(mcmc_vector2)
plot2 = plot(seq_along(beta_mean), beta_mean, xlab = 'Time', ylab = 'beta', main = paste("Mean of beta MCMC chain, true beta = ", betaX))
print(plot2)
#Histogram
#hist1 = hist(mcmc_vector, prob = TRUE)
#print(hist1)
#Hist
hist2 <- hist(mcmc_vector2, breaks = 80)
hist2$counts <- hist2$counts/sum(hist2$counts)
hist3 = plot(hist2, xlab = 'alpha', ylab = 'Density',
main = 'Empirical density of beta - MCMC chain')
print(hist3)
#**************************************************
#*gamma
#i. MCMC chain
plot.ts(mcmc_vector3, ylab = 'gamma', main = paste("MCMC Results; gamma - Super spreading model, true gamma = ", gammaX))
#print(plot1)
#ii. Mean
#Plot mean
gamma_mean = cumsum(mcmc_vector3)/seq_along(mcmc_vector3)
plot2 = plot(seq_along(gamma_mean), gamma_mean, xlab = 'Time', ylab = 'gamma', main = paste("Mean of gamma MCMC chain, True gamma = ", gammaX))
print(plot2)
#Histogram
#hist1 = hist(mcmc_vector, prob = TRUE)
#print(hist1)
#Hist
hist2 <- hist(mcmc_vector3, breaks = 80)
hist2$counts <- hist2$counts/sum(hist2$counts)
hist3 = plot(hist2, xlab = 'gamma', ylab = 'Density',
main = 'Empirical density of gamma - MCMC chain')
print(hist3)
dev.off()
}
plot_mcmc_super_spreading_to_screen(sim_data, alpha_mcmc, beta_mcmc, gamma_mcmc, alphaX, betaX, gammaX, file_name, folder_dir_ad)
View(mcmc_params_ad)
View(mcmc_params_ad)
#Plot
plot.ts(alpha_mcmc, ylab = 'alpha', main = paste("MCMC Super spreading model, simulated alpha = ", alphaX))
plot.ts(beta_mcmc, ylab = 'beta', main = paste("MCMC Super spreading model, simulated beta = ", betaX))
plot.ts(gamma_mcmc,  ylab = 'gamma', main = paste("MCMC Super spreading model, simulated gamma = ", gammaX))
#alpha mean
alpha_mean = cumsum(alpha_mcmc)/seq_along(alpha_mcmc)
plot2 = plot(seq_along(alpha_mean), alpha_mean, xlab = 'Time', ylab = 'alpha', main = paste("Mean of alpha MCMC chain, True alpha = ",alphaX))
print(plot2)
#beta mean
beta_mean = cumsum(beta_mcmc)/seq_along(beta_mcmc)
plot2 = plot(seq_along(beta_mean), beta_mean, xlab = 'Time', ylab = 'beta', main = paste("Mean of beta MCMC chain, True beta = ",betaX))
print(plot2)
#gamma Mean
gamma_mean = cumsum(gamma_mcmc)/seq_along(gamma_mcmc)
plot2 = plot(seq_along(gamma_mean), gamma_mean, xlab = 'Time', ylab = 'gamma', main = paste("Mean of gamma MCMC chain, True gamma = ",gammaX))
print(plot2)
