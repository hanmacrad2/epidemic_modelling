list_time_taken[i] = time_elap
i = i + 1
#Apply Plotting
mcmc_plotting_adaptive(r0_mcmc, r0X, folder_dir_ad)
}
#Create dataframe
df_results <- data.frame(
r0 = list_r0,
acceptance_rate = unlist(list_accept_rate),
num_samples = unlist(list_num_samp),
time_mcmc = unlist(list_time_taken),
sd_final = unlist(list_sd))
print(df_results)
df_results
}
#Apply
sigma = 0.75
folder_dir_ad = 'Results/Adaptive_MC/adaptive_mc_iter_IV_burn_in_5k'
list_r0 = c(0.7, 0.8, 0.9, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0)  #c(0.8, 0.9, 1.0, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0) #c(0.8, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5,
#list_r0 = c(0.5, 0.65, 0.70, 0.75, 0.8, 0.85, 0.95, 1.05, 2.80, 3.05, 3.55, 4.05, 4.55, 5.05, 8.05, 10.05)
df_ad_results_formI = apply_adaptive_mc_range_r0(list_r0, sigma, folder_dir_ad)
j = c(1, 2, 3)
if (1 in j){
print('yes')
}
is.element(5,c(1:5))
if (is.element(5,c(1:5))){
print('yes')
}
folder_dir_ad = 'Results/Adaptive_MC/adaptive_mc_iter_IV_burn_in_5k'
list_r0 = c(0.7, 0.8, 0.9, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0)  #c(0.8, 0.9, 1.0, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0) #c(0.8, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5,
#list_r0 = c(0.5, 0.65, 0.70, 0.75, 0.8, 0.85, 0.95, 1.05, 2.80, 3.05, 3.55, 4.05, 4.55, 5.05, 8.05, 10.05)
df_ad_results_formI = apply_adaptive_mc_range_r0(list_r0, sigma, folder_dir_ad)
j
j[2:]
j[1]
ncol(j)
length(j)
j[2:length(j)]
adaptive_mc_r0 <- function(data, n, sigma, x0 = 1, burn_in = 5000) { #burn_in = 2500
'Returns mcmc samples of R0 & acceptance rate'
#Set up
r0_vec <- vector('numeric', n)
r0_vec[1] <- x0
U <- runif(n)
count_accept = 0
count_reject = 0
sd_sample = 1
#MCMC chain
for(i in 2:n) {
#New Proposal
Y <- r0_vec[i-1] + rnorm(1, sd = sigma)
if(Y < 0){
Y = abs(Y)
}
log_alpha = log_like(data, Y) - log_like(data, r0_vec[i-1]) + dgamma(Y, shape = 1, scale = 1, log = TRUE) - dgamma(r0_vec[i-1], shape = 1, scale = 1, log = TRUE) #log_prior(theta_dash) - log_prior(theta) = 1 - 1
#if (is.na(log_alpha)){
#print('na value, Y value:')
#print(Y)
#}
if(!(is.na(log_alpha)) && log(U[i]) < log_alpha) {
r0_vec[i] <- Y
count_accept = count_accept + 1
} else {
r0_vec[i] <- r0_vec[i-1]
count_reject = count_reject + 1
}
#Adaptive MC
if (i == burn_in){
sigma = var(r0_vec[2:i])*(2.38^2)
}
}
#Final stats
total_iters = count_accept + count_reject
accept_rate = 100*(count_accept/(count_accept+count_reject))
num_samples = count_accept
print("Total iterations = ")
print(total_iters)
print("Acceptance rate = ")
print(accept_rate)
print("Number samples = ")
print(count_accept)
#Burn-in
r0_vec = r0_vec[burn_in:n]
#Return r0, acceptance rate
return(list(r0_vec, accept_rate, num_samples, sigma))
}
apply_adaptive_mc_range_r0 <- function(list_r0, sigma, folder_dir_ad){
#Create folder
ifelse(!dir.exists(file.path(folder_dir_ad)), dir.create(file.path(folder_dir_ad)), FALSE)
list_accept_rate = vector('numeric', length(list_r0))
list_sd = vector('numeric', length(list_r0))
list_num_samp = vector('numeric', length(list_r0))
list_time_taken = vector('numeric', length(list_r0))
i = 1
for (r0X in list_r0){
#Get simulated data when r0 is r0X
data = simulate_branching(num_days, r0X, shape_gamma, scale_gamma)
#Time
start_time = Sys.time()
mcmc_params_ad = adaptive_mc_r0(data, n, sigma)
end_time = Sys.time()
time_elap = end_time - start_time
print('Time elapsed:')
print(time_elap)
#Extract params
r0_mcmc = mcmc_params_ad[1]
r0_mcmc = unlist(r0_mcmc)
accept_rate = mcmc_params_ad[2]
list_accept_rate[i] = accept_rate
num_samples = mcmc_params_ad[3]
list_num_samp[i] = num_samples
sd_final = mcmc_params_ad[4]
list_sd[i] = sd_final
list_time_taken[i] = time_elap
i = i + 1
#Apply Plotting
mcmc_plotting_adaptive(r0_mcmc, r0X, folder_dir_ad)
}
#Create dataframe
df_results <- data.frame(
r0 = list_r0,
acceptance_rate = unlist(list_accept_rate),
num_samples = unlist(list_num_samp),
time_mcmc = unlist(list_time_taken),
sd_final = unlist(list_sd))
print(df_results)
df_results
}
#Apply
sigma = 0.75
folder_dir_ad = 'Results/Adaptive_MC/adaptive_mc_iter_IV_burn_in_5k'
list_r0 = c(0.7, 0.8, 0.9, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0)  #c(0.8, 0.9, 1.0, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0) #c(0.8, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5,
#list_r0 = c(0.5, 0.65, 0.70, 0.75, 0.8, 0.85, 0.95, 1.05, 2.80, 3.05, 3.55, 4.05, 4.55, 5.05, 8.05, 10.05)
df_ad_results_formI = apply_adaptive_mc_range_r0(list_r0, sigma, folder_dir_ad)
round(3.45324, 3)
round(53.45324, 2)
round(0.45324, 3)
apply_adaptive_mc_range_r0 <- function(list_r0, sigma, folder_dir_ad){
#Create folder
ifelse(!dir.exists(file.path(folder_dir_ad)), dir.create(file.path(folder_dir_ad)), FALSE)
list_accept_rate = vector('numeric', length(list_r0))
list_sd = vector('numeric', length(list_r0))
list_num_samp = vector('numeric', length(list_r0))
list_time_taken = vector('numeric', length(list_r0))
i = 1
for (r0X in list_r0){
#Get simulated data when r0 is r0X
data = simulate_branching(num_days, r0X, shape_gamma, scale_gamma)
#Time
start_time = Sys.time()
mcmc_params_ad = adaptive_mc_r0(data, n, sigma)
end_time = Sys.time()
time_elap = end_time - start_time
print('Time elapsed:')
print(time_elap)
#Extract params
r0_mcmc = mcmc_params_ad[1]
r0_mcmc = unlist(r0_mcmc)
accept_rate = mcmc_params_ad[2]
list_accept_rate[i] = round(accept_rate, 2)
num_samples = mcmc_params_ad[3]
list_num_samp[i] = num_samples
sd_final = mcmc_params_ad[4]
list_sd[i] = round(sd_final, 3)
list_time_taken[i] = round(time_elap, 2)
i = i + 1
#Apply Plotting
mcmc_plotting_adaptive(r0_mcmc, r0X, folder_dir_ad)
}
#Create dataframe
df_results <- data.frame(
r0 = list_r0,
acceptance_rate = unlist(list_accept_rate),
num_samples = unlist(list_num_samp),
time_mcmc_sec = unlist(list_time_taken),
sd_final = unlist(list_sd))
print(df_results)
df_results
}
#Apply
sigma = 0.75
folder_dir_ad = 'Results/Adaptive_MC/adaptive_mc_iter_V_burn_in_5k'
list_r0 = c(0.7, 0.8, 0.9, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0)  #c(0.8, 0.9, 1.0, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0) #c(0.8, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5,
#list_r0 = c(0.5, 0.65, 0.70, 0.75, 0.8, 0.85, 0.95, 1.05, 2.80, 3.05, 3.55, 4.05, 4.55, 5.05, 8.05, 10.05)
df_ad_results_formI = apply_adaptive_mc_range_r0(list_r0, sigma, folder_dir_ad)
typeof(time_elap)
round(time_elap, 2)
time_elap
apply_adaptive_mc_range_r0 <- function(list_r0, sigma, folder_dir_ad){
#Create folder
ifelse(!dir.exists(file.path(folder_dir_ad)), dir.create(file.path(folder_dir_ad)), FALSE)
list_accept_rate = vector('numeric', length(list_r0))
list_sd = vector('numeric', length(list_r0))
list_num_samp = vector('numeric', length(list_r0))
list_time_taken = vector('numeric', length(list_r0))
i = 1
for (r0X in list_r0){
#Get simulated data when r0 is r0X
data = simulate_branching(num_days, r0X, shape_gamma, scale_gamma)
#Time
start_time = Sys.time()
mcmc_params_ad = adaptive_mc_r0(data, n, sigma)
end_time = Sys.time()
time_elap = end_time - start_time
print('Time elapsed:')
print(time_elap)
#Extract params
r0_mcmc = mcmc_params_ad[1]
r0_mcmc = unlist(r0_mcmc)
accept_rate = mcmc_params_ad[2]
print('Acceptance rate type:')
print(typeof(accept_rate))
list_accept_rate[i] = round(accept_rate, 2)
num_samples = mcmc_params_ad[3]
list_num_samp[i] = num_samples
sd_final = mcmc_params_ad[4]
list_sd[i] = round(sd_final, 3)
list_time_taken[i] = round(time_elap, 2)
i = i + 1
#Apply Plotting
mcmc_plotting_adaptive(r0_mcmc, r0X, folder_dir_ad)
}
#Create dataframe
df_results <- data.frame(
r0 = list_r0,
acceptance_rate = unlist(list_accept_rate),
num_samples = unlist(list_num_samp),
time_mcmc_sec = unlist(list_time_taken),
sd_final = unlist(list_sd))
print(df_results)
df_results
}
#Apply
sigma = 0.75
folder_dir_ad = 'Results/Adaptive_MC/adaptive_mc_iter_V_burn_in_5k'
list_r0 = c(0.7, 0.8, 0.9, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0)  #c(0.8, 0.9, 1.0, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0) #c(0.8, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5,
#list_r0 = c(0.5, 0.65, 0.70, 0.75, 0.8, 0.85, 0.95, 1.05, 2.80, 3.05, 3.55, 4.05, 4.55, 5.05, 8.05, 10.05)
df_ad_results_formI = apply_adaptive_mc_range_r0(list_r0, sigma, folder_dir_ad)
apply_adaptive_mc_range_r0 <- function(list_r0, sigma, folder_dir_ad){
#Create folder
ifelse(!dir.exists(file.path(folder_dir_ad)), dir.create(file.path(folder_dir_ad)), FALSE)
list_accept_rate = vector('numeric', length(list_r0))
list_sd = vector('numeric', length(list_r0))
list_num_samp = vector('numeric', length(list_r0))
list_time_taken = vector('numeric', length(list_r0))
i = 1
for (r0X in list_r0){
#Get simulated data when r0 is r0X
data = simulate_branching(num_days, r0X, shape_gamma, scale_gamma)
#Time
start_time = Sys.time()
mcmc_params_ad = adaptive_mc_r0(data, n, sigma)
end_time = Sys.time()
time_elap = end_time - start_time
print('Time elapsed:')
print(time_elap)
#Extract params
r0_mcmc = mcmc_params_ad[1]
r0_mcmc = unlist(r0_mcmc)
accept_rate = mcmc_params_ad[2][1]
print('Acceptance rate type:')
print(typeof(accept_rate))
list_accept_rate[i] = round(accept_rate, 2)
num_samples = mcmc_params_ad[3]
list_num_samp[i] = num_samples
sd_final = mcmc_params_ad[4]
list_sd[i] = round(sd_final, 3)
list_time_taken[i] = round(time_elap, 2)
i = i + 1
#Apply Plotting
mcmc_plotting_adaptive(r0_mcmc, r0X, folder_dir_ad)
}
#Create dataframe
df_results <- data.frame(
r0 = list_r0,
acceptance_rate = unlist(list_accept_rate),
num_samples = unlist(list_num_samp),
time_mcmc_sec = unlist(list_time_taken),
sd_final = unlist(list_sd))
print(df_results)
df_results
}
#Apply
sigma = 0.75
folder_dir_ad = 'Results/Adaptive_MC/adaptive_mc_iter_V_burn_in_5k'
list_r0 = c(0.7, 0.8, 0.9, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0)  #c(0.8, 0.9, 1.0, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0) #c(0.8, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5,
#list_r0 = c(0.5, 0.65, 0.70, 0.75, 0.8, 0.85, 0.95, 1.05, 2.80, 3.05, 3.55, 4.05, 4.55, 5.05, 8.05, 10.05)
df_ad_results_formI = apply_adaptive_mc_range_r0(list_r0, sigma, folder_dir_ad)
k = list(1,34, 43)
k[1]
k[1][1]
k[1][1][1]
typeof(k[1][1][1])
k[[1]]
typeof(k[[1]])
apply_adaptive_mc_range_r0 <- function(list_r0, sigma, folder_dir_ad){
#Create folder
ifelse(!dir.exists(file.path(folder_dir_ad)), dir.create(file.path(folder_dir_ad)), FALSE)
list_accept_rate = vector('numeric', length(list_r0))
list_sd = vector('numeric', length(list_r0))
list_num_samp = vector('numeric', length(list_r0))
list_time_taken = vector('numeric', length(list_r0))
i = 1
for (r0X in list_r0){
#Get simulated data when r0 is r0X
data = simulate_branching(num_days, r0X, shape_gamma, scale_gamma)
#Time
start_time = Sys.time()
mcmc_params_ad = adaptive_mc_r0(data, n, sigma)
end_time = Sys.time()
time_elap = end_time - start_time
print('Time elapsed:')
print(time_elap)
#Extract params
r0_mcmc = mcmc_params_ad[1]
r0_mcmc = unlist(r0_mcmc)
accept_rate = mcmc_params_ad[[2]]
list_accept_rate[i] = round(accept_rate, 2)
num_samples = mcmc_params_ad[[3]]
list_num_samp[i] = num_samples
sd_final = mcmc_params_ad[[4]]
list_sd[i] = round(sd_final, 3)
list_time_taken[i] = round(time_elap, 2)
i = i + 1
#Apply Plotting
mcmc_plotting_adaptive(r0_mcmc, r0X, folder_dir_ad)
}
#Create dataframe
df_results <- data.frame(
r0 = list_r0,
acceptance_rate = unlist(list_accept_rate),
num_samples = unlist(list_num_samp),
time_mcmc_sec = unlist(list_time_taken),
sd_final = unlist(list_sd))
print(df_results)
df_results
}
#Apply
sigma = 0.75
folder_dir_ad = 'Results/Adaptive_MC/adaptive_mc_iter_V_burn_in_5k'
list_r0 = c(0.7, 0.8, 0.9, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0)  #c(0.8, 0.9, 1.0, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0) #c(0.8, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5,
#list_r0 = c(0.5, 0.65, 0.70, 0.75, 0.8, 0.85, 0.95, 1.05, 2.80, 3.05, 3.55, 4.05, 4.55, 5.05, 8.05, 10.05)
df_ad_results_formI = apply_adaptive_mc_range_r0(list_r0, sigma, folder_dir_ad)
apply_adaptive_mc_range_r0 <- function(list_r0, sigma, folder_dir_ad){
#Create folder
ifelse(!dir.exists(file.path(folder_dir_ad)), dir.create(file.path(folder_dir_ad)), FALSE)
list_accept_rate = vector('numeric', length(list_r0))
list_sd = vector('numeric', length(list_r0))
list_num_samp = vector('numeric', length(list_r0))
list_time_taken = vector('numeric', length(list_r0))
i = 1
for (r0X in list_r0){
#Get simulated data when r0 is r0X
data = simulate_branching(num_days, r0X, shape_gamma, scale_gamma)
#Time
start_time = Sys.time()
mcmc_params_ad = adaptive_mc_r0(data, n, sigma)
end_time = Sys.time()
time_elap = end_time - start_time
print('Time elapsed:')
print(time_elap)
#Extract params
r0_mcmc = mcmc_params_ad[1]
r0_mcmc = unlist(r0_mcmc)
accept_rate = mcmc_params_ad[[2]]
list_accept_rate[i] = round(accept_rate, 2)
num_samples = mcmc_params_ad[[3]]
list_num_samp[i] = num_samples
sd_final = mcmc_params_ad[[4]]
list_sd[i] = round(sd_final, 3)
list_time_taken[i] = round(time_elap, 2)
i = i + 1
#Apply Plotting
mcmc_plotting_adaptive(r0_mcmc, r0X, folder_dir_ad)
}
#Create dataframe
df_results <- data.frame(
r0 = list_r0,
accept_rate = unlist(list_accept_rate),
n_samples = unlist(list_num_samp),
time_sec = unlist(list_time_taken),
sd_final = unlist(list_sd))
print(df_results)
df_results
}
#Apply
sigma = 0.75
folder_dir_ad = 'Results/Adaptive_MC/adaptive_mc_iter_VI_burn_in_5k'
list_r0 = c(0.7, 0.8, 0.9, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0)  #c(0.8, 0.9, 1.0, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0) #c(0.8, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5,
#list_r0 = c(0.5, 0.65, 0.70, 0.75, 0.8, 0.85, 0.95, 1.05, 2.80, 3.05, 3.55, 4.05, 4.55, 5.05, 8.05, 10.05)
df_ad_results_formI = apply_adaptive_mc_range_r0(list_r0, sigma, folder_dir_ad)
folder_dir_ad = 'Results/Adaptive_MC/adaptive_mc_iter_VII_burn_in_5k'
list_r0 = c(0.7, 0.8, 0.9, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0)  #c(0.8, 0.9, 1.0, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0) #c(0.8, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5,
#list_r0 = c(0.5, 0.65, 0.70, 0.75, 0.8, 0.85, 0.95, 1.05, 2.80, 3.05, 3.55, 4.05, 4.55, 5.05, 8.05, 10.05)
df_ad_results_formI = apply_adaptive_mc_range_r0(list_r0, sigma, folder_dir_ad)
#Simulate Branching Process
par(mar=c(1,1,1,1))
#Parameters
num_days = 100
r0 = 3.1
shape_gamma = 6
scale_gamma = 1
#Function
simulate_branching_ss = function(num_days, r0, shape_gamma, scale_gamma, prop_ss, magnitude_ss) {
'Simulate an epidemic with Superspreading events'
#Set up
vec_infecteds = vector('numeric', num_days)
vec_infecteds[1] = 1
#Infectiousness (Discrete gamma) - I.e 'Infectiousness Pressure' - Sum of all people
#Explanation: Gamma is a continuous function so integrate over the density at that point in time (today - previous day)
prob_infect = pgamma(c(1:num_days), shape = shape_gamma, scale = scale_gamma) - pgamma(c(0:(num_days-1)), shape = shape_gamma, scale = scale_gamma)
#Superspreading days
days_ss = ceiling(runif(round(prop_ss*num_days), 2, num_days))
#Days of Infection Spreading
for (t in 2:num_days) {
#Probability p == Super-spreading event
#Check if in list then superspreading
if (is.element(5,c(1:5))) {
tot_rate = magnitude_ss*r0*sum(vec_infecteds[1:(t-1)]*rev(prob_infect[1:(t-1)]))
} else {
tot_rate = r0*sum(vec_infecteds[1:(t-1)]*rev(prob_infect[1:(t-1)])) #Product of infecteds & their probablilty of infection along the gamma dist at that point in time
}
#Total rate
vec_infecteds[t] = rpois(1, tot_rate) #Assuming number of cases each day follows a poisson distribution. Causes jumps in data
}
vec_infecteds
}
#Implement
start_time = Sys.time()
prop_ss = 0.05
magnitude_ss = 10
x = simulate_branching_ss(num_days, r0, shape_gamma, scale_gamma, prop_ss, magnitude_ss)
end_time = Sys.time()
time_elap = end_time - start_time
#print(time_elap)
#x
#Plots
plot.ts(x, ylab = "N Daily infections")
cum_data <- cumsum(x)
plot.ts(cum_data)
start_time = Sys.time()
prop_ss = 0.05
magnitude_ss = 10
x = simulate_branching_ss(num_days, r0, shape_gamma, scale_gamma, prop_ss, magnitude_ss)
end_time = Sys.time()
time_elap = end_time - start_time
#print(time_elap)
plot.ts(x, ylab = "N Daily infections")
cum_data <- cumsum(x)
plot.ts(cum_data)
#Plots
plot.ts(x, ylab = "N Daily infections")
cum_data <- cumsum(x)
x = simulate_branching(num_days, r0, shape_gamma, scale_gamma)
#Plots
plot.ts(x, ylab = "N Daily infections")
#Parameters
num_days = 30 #100
x = simulate_branching(num_days, r0, shape_gamma, scale_gamma)
start_time = Sys.time()
x = simulate_branching(num_days, r0, shape_gamma, scale_gamma)
end_time = Sys.time()
time_elap = end_time - start_time
#Plots
plot.ts(x, ylab = "N Daily infections")
x = simulate_branching_ss(num_days, r0, shape_gamma, scale_gamma, prop_ss, magnitude_ss)
#Plots
plot.ts(x, ylab = "N Daily infections")
#Parameters
num_days = 10#30, 100
x = simulate_branching_ss(num_days, r0, shape_gamma, scale_gamma, prop_ss, magnitude_ss)
#Plots
plot.ts(x, ylab = "N Daily infections")
simulate_branching_ss = function(num_days, r0, shape_gamma, scale_gamma, prop_ss, magnitude_ss) {
'Simulate an epidemic with Superspreading events'
#Set up
vec_infecteds = vector('numeric', num_days)
vec_infecteds[1] = 1
#Infectiousness (Discrete gamma) - I.e 'Infectiousness Pressure' - Sum of all people
#Explanation: Gamma is a continuous function so integrate over the density at that point in time (today - previous day)
prob_infect = pgamma(c(1:num_days), shape = shape_gamma, scale = scale_gamma) - pgamma(c(0:(num_days-1)), shape = shape_gamma, scale = scale_gamma)
#Superspreading days
days_ss = ceiling(runif(round(prop_ss*num_days), 2, num_days))
#Days of Infection Spreading
for (t in 2:num_days) {
#Probability p == Super-spreading event
#Check if in list then superspreading
if (is.element(t, days_ss)) {
tot_rate = magnitude_ss*r0*sum(vec_infecteds[1:(t-1)]*rev(prob_infect[1:(t-1)]))
} else {
tot_rate = r0*sum(vec_infecteds[1:(t-1)]*rev(prob_infect[1:(t-1)])) #Product of infecteds & their probablilty of infection along the gamma dist at that point in time
}
#Total rate
vec_infecteds[t] = rpois(1, tot_rate) #Assuming number of cases each day follows a poisson distribution. Causes jumps in data
}
vec_infecteds
}
start_time = Sys.time()
prop_ss = 0.05
magnitude_ss = 10
x = simulate_branching_ss(num_days, r0, shape_gamma, scale_gamma, prop_ss, magnitude_ss)
end_time = Sys.time()
time_elap = end_time - start_time
#
#Plots
plot.ts(x, ylab = "N Daily infections")
#Parameters
num_days = 30 #100
x = simulate_branching_ss(num_days, r0, shape_gamma, scale_gamma, prop_ss, magnitude_ss)
#Plots
plot.ts(x, ylab = "N Daily infections")
