View(fx)
View(fx)
View(fx)
seq(-3,3,length=10)
get_fx = function(n = 1000){
#Matrix
fx = matrix(0, nrow = 3, ncol = n)
X1 = seq(-3,3,length=1000)
X2 = seq(-2,2,length=1000)
count = 1
for (x_1 in X1) {
for (x_2 in X2){
print(count)
fx[1, count] = x_1
fx[2, count] = x_2
fx[3, count] = (4 -2.1*x_1^2 + (x_1^4)/3)*x_1^2 + x_1*x_2 + 4*(x_2^2 -1)*x_2^2
count = count + 1
print(x_1)
print(x_2)
print(fx[3, count])
}
}
fx
}
#fx - apply
fx = get_fx()
get_fx = function(n = 20){
#Matrix
fx = matrix(0, nrow = 3, ncol = n)
X1 = seq(-3,3,length=n)
X2 = seq(-2,2,length=n)
count = 1
for (x_1 in X1) {
for (x_2 in X2){
print(count)
fx[1, count] = x_1
fx[2, count] = x_2
fx[3, count] = (4 -2.1*x_1^2 + (x_1^4)/3)*x_1^2 + x_1*x_2 + 4*(x_2^2 -1)*x_2^2
count = count + 1
print(x_1)
print(x_2)
print(fx[3, count])
}
}
fx
}
#fx - apply
fx = get_fx()
get_fx = function(n = 10){
#Matrix
fx = matrix(0, nrow = 3, ncol = n)
X1 = seq(-3,3,length=n)
X2 = seq(-2,2,length=n)
count = 1
for (x_1 in X1) {
for (x_2 in X2){
print(count)
fx[1, count] = x_1
fx[2, count] = x_2
fx[3, count] = (4 -2.1*x_1^2 + (x_1^4)/3)*x_1^2 + x_1*x_2 + 4*(x_2^2 -1)*x_2^2
count = count + 1
print(x_1)
print(x_2)
print(fx[3, count])
}
}
fx
}
#fx - apply
fx = get_fx()
get_fx = function(n = 10){
#Matrix
fx = matrix(0, nrow = 3, ncol = n)
X1 = seq(-3,3,length=n)
X2 = seq(-2,2,length=n)
count = 1
for (x_1 in X1) {
for (x_2 in X2){
print(count)
fx[1, count] = x_1
fx[2, count] = x_2
fx[3, count] = (4 -2.1*x_1^2 + (x_1^4)/3)*x_1^2 + x_1*x_2 + 4*(x_2^2 -1)*x_2^2
print(x_1)
print(x_2)
print(fx[3, count])
count = count + 1
}
}
fx
}
#fx - apply
fx = get_fx()
get_fx = function(n = 10){
#Matrix
fx = matrix(0, nrow = 3, ncol = n)
X1 = seq(-3,3,length=n)
X2 = seq(-2,2,length=n)
count = 1
while (count <= n) {
for (x_1 in X1) {
for (x_2 in X2){
print(count)
fx[1, count] = x_1
fx[2, count] = x_2
fx[3, count] = (4 -2.1*x_1^2 + (x_1^4)/3)*x_1^2 + x_1*x_2 + 4*(x_2^2 -1)*x_2^2
print(x_1)
print(x_2)
print(fx[3, count])
count = count + 1
}
}
}
fx
}
#fx - apply
fx = get_fx()
get_fx = function(n = 10){
#Matrix
fx = matrix(0, nrow = 3, ncol = n)
X1 = seq(-3,3,length=n)
X2 = seq(-2,2,length=n)
count = 1
while (count <= n) {
for (x_1 in X1) {
for (x_2 in X2){
print(count)
fx[1, count] = x_1
fx[2, count] = x_2
fx[3, count] = (4 -2.1*x_1^2 + (x_1^4)/3)*x_1^2 + x_1*x_2 + 4*(x_2^2 -1)*x_2^2
print(x_1)
print(x_2)
print(fx[3, count])
count = count + 1
}
}
}
fx
}
#fx - apply
fx = get_fx()
50*50
1000/10
get_fx = function(len_x = 3){
#Matrix
X1 = seq(-3,3,length=len_x)
X2 = seq(-2,2,length=len_x)
fx = matrix(0, nrow = 3, ncol = len_x^2)
count = 1
while (count <= n) {
for (x_1 in X1) {
for (x_2 in X2){
print(count)
fx[1, count] = x_1
fx[2, count] = x_2
fx[3, count] = (4 -2.1*x_1^2 + (x_1^4)/3)*x_1^2 + x_1*x_2 + 4*(x_2^2 -1)*x_2^2
print(x_1)
print(x_2)
print(fx[3, count])
count = count + 1
}
}
}
fx
}
#fx - apply
fx = get_fx()
get_fx = function(len_x = 4){
#Matrix
X1 = seq(-3,3,length=len_x)
X2 = seq(-2,2,length=len_x)
fx = matrix(0, nrow = 3, ncol = len_x^2)
count = 1
while (count <= len_x) {
for (x_1 in X1) {
for (x_2 in X2){
print(count)
fx[1, count] = x_1
fx[2, count] = x_2
fx[3, count] = (4 -2.1*x_1^2 + (x_1^4)/3)*x_1^2 + x_1*x_2 + 4*(x_2^2 -1)*x_2^2
print(x_1)
print(x_2)
print(fx[3, count])
count = count + 1
}
}
}
fx
}
#fx - apply
fx = get_fx()
View(fx)
View(fx)
#plot
library(plotly)
install.packages("plotly")
#plot
library(plotly)
# Plot
p <- plot_ly(x = fx[3, ,], y = fx[3, ,], z = fx[3, ,], type = "surface")
# Plot
p <- plot_ly(x = fx[3,], y = fx[3 ,], z = fx[3 ,], type = "surface")
p
X1 = seq(-3,3,length=len_x)
X2 = seq(-2,2,length=len_x)
len_x = 10
#Matrix
X1 = seq(-3,3,length=len_x)
X2 = seq(-2,2,length=len_x)
get_fx = function(len_x = 10){
#Matrix
X1 = seq(-3,3,length=len_x)
X2 = seq(-2,2,length=len_x)
fx = matrix(0, nrow = 3, ncol = len_x^2)
count = 1
while (count <= len_x) {
for (x_1 in X1) {
for (x_2 in X2){
print(count)
fx[1, count] = x_1
fx[2, count] = x_2
fx[3, count] = (4 -2.1*x_1^2 + (x_1^4)/3)*x_1^2 + x_1*x_2 + 4*(x_2^2 -1)*x_2^2
print(x_1)
print(x_2)
print(fx[3, count])
count = count + 1
}
}
}
fx
}
#fx - apply
fx = get_fx()
persp(X1, X2, fx[3,],
xlab = "x1", ylab = "x2",
main = "f(x1, x2)"
)
View(fx)
View(fx)
help(plot3d)
??plot3d
install.packages("rgl")
library(rgl)
plot3d(x = fx[1,], y = fx[2 ,], z = fx[3 ,], type = "surface")
plot3d(x = fx[1,], y = fx[2 ,], z = fx[3 ,], type = "surface")
p = plot3d(x = fx[1,], y = fx[2 ,], z = fx[3 ,], type = "surface")
p
surf3d(x = fx[1,], y = fx[2 ,], z = fx[3 ,], type = "surface")
rglwidget(elementId = "plot3drgl")
install.packages("plot3D")
surf3d(x = fx[1,], y = fx[2 ,], z = fx[3 ,], type = "surface")
library(plot3d)
library(plot3D)
surf3d(x = fx[1,], y = fx[2 ,], z = fx[3 ,], type = "surface")
surf3D(x = fx[1,], y = fx[2 ,], z = fx[3 ,], type = "surface")
fig <- plot_ly(x = fx[1,], y = fx[2 ,], z = fx[3 ,]) %>% add_surface()
fig
z = matrix(fx[3 ,], nrow = 1, ncol = len_x^2)
fig <- plot_ly(x = fx[1,], y = fx[2 ,], z = z) %>% add_surface()
fig
source("functions.R")
apply_adaptive_scaling_mc_range_r0 <- function(list_r0, sigma, folder_dir_ad){
#Create folder
ifelse(!dir.exists(file.path(folder_dir_ad)), dir.create(file.path(folder_dir_ad)), FALSE)
list_accept_rate = vector('numeric', length(list_r0))
list_sd = vector('numeric', length(list_r0))
list_num_samp = vector('numeric', length(list_r0))
list_time_taken = vector('numeric', length(list_r0))
i = 1
for (r0X in list_r0){
#Get simulated data when r0 is r0X
print(r0X)
data = simulate_branching(num_days, r0X, shape_gamma, scale_gamma)
#Time
start_time = Sys.time()
mcmc_params_ad = adaptive_scaling_metropolis_r0(data, n, sigma)
end_time = Sys.time()
time_elap = end_time - start_time
print('Time elapsed:')
print(time_elap)
#Extract params
r0_mcmc = mcmc_params_ad[1]
r0_mcmc = unlist(r0_mcmc)
accept_rate = mcmc_params_ad[[2]]
list_accept_rate[i] = round(accept_rate, 2)
num_samples = mcmc_params_ad[[3]]
list_num_samp[i] = num_samples
sd_final = mcmc_params_ad[[4]]
list_sd[i] = round(sd_final, 3)
list_time_taken[i] = round(time_elap, 2)
i = i + 1
#Apply Plotting
mcmc_plotting_adaptive(r0_mcmc, r0X, folder_dir_ad)
}
#Create dataframe
df_results <- data.frame(
r0 = list_r0,
accept_rate = unlist(list_accept_rate),
n_samples = unlist(list_num_samp),
time_sec = unlist(list_time_taken),
sd_final = unlist(list_sd))
print(df_results)
df_results
}
#Apply
sigma = 0.75
folder_dir_ad = 'Results/Adaptive_scaling_MCMC/adaptive_mcmc_iter_I'
list_r0 = c(0.7, 0.8, 0.9, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0)  #c(0.8, 0.9, 1.0, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0) #c(0.8, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5,
#list_r0 = c(0.5, 0.65, 0.70, 0.75, 0.8, 0.85, 0.95, 1.05, 2.80, 3.05, 3.55, 4.05, 4.55, 5.05, 8.05, 10.05)
df_ad_results_formI = apply_adaptive_scaling_mc_range_r0(list_r0, sigma, folder_dir_ad)
df_ad_results_formI
setwd("~/GitHub/epidemic_modelling")
#Apply
sigma = 0.75
folder_dir_ad = 'Results/Adaptive_scaling_MCMC/adaptive_mcmc_iter_I'
list_r0 = c(0.7, 0.8, 0.9, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0)  #c(0.8, 0.9, 1.0, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0) #c(0.8, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5,
#list_r0 = c(0.5, 0.65, 0.70, 0.75, 0.8, 0.85, 0.95, 1.05, 2.80, 3.05, 3.55, 4.05, 4.55, 5.05, 8.05, 10.05)
df_ad_results_formI = apply_adaptive_scaling_mc_range_r0(list_r0, sigma, folder_dir_ad)
df_ad_results_formI
apply_adaptive_scaling_mc_range_r0 <- function(list_r0, sigma, folder_dir_ad){
#Create folder
ifelse(!dir.exists(file.path(folder_dir_ad)), dir.create(file.path(folder_dir_ad)), FALSE)
list_accept_rate = vector('numeric', length(list_r0))
list_sd = vector('numeric', length(list_r0))
list_num_samp = vector('numeric', length(list_r0))
list_time_taken = vector('numeric', length(list_r0))
i = 1
for (r0X in list_r0){
#Get simulated data when r0 is r0X
print(r0X)
data = simulate_branching(num_days, r0X, shape_gamma, scale_gamma)
#Time
start_time = Sys.time()
mcmc_params_ad = adaptive_scaling_metropolis_r0(data, n, sigma, alpha_star)
end_time = Sys.time()
time_elap = end_time - start_time
print('Time elapsed:')
print(time_elap)
#Extract params
r0_mcmc = mcmc_params_ad[1]
r0_mcmc = unlist(r0_mcmc)
accept_rate = mcmc_params_ad[[2]]
list_accept_rate[i] = round(accept_rate, 2)
num_samples = mcmc_params_ad[[3]]
list_num_samp[i] = num_samples
sd_final = mcmc_params_ad[[4]]
list_sd[i] = round(sd_final, 3)
list_time_taken[i] = round(time_elap, 2)
i = i + 1
#Apply Plotting
mcmc_plotting_adaptive(r0_mcmc, r0X, folder_dir_ad)
}
#Create dataframe
df_results <- data.frame(
r0 = list_r0,
accept_rate = unlist(list_accept_rate),
n_samples = unlist(list_num_samp),
time_sec = unlist(list_time_taken),
sd_final = unlist(list_sd))
print(df_results)
df_results
}
#Apply
sigma = 0.75
folder_dir_ad = 'Results/Adaptive_scaling_MCMC/adaptive_mcmc_iter_I'
list_r0 = c(0.7, 0.8, 0.9, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0)  #c(0.8, 0.9, 1.0, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0) #c(0.8, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5,
#list_r0 = c(0.5, 0.65, 0.70, 0.75, 0.8, 0.85, 0.95, 1.05, 2.80, 3.05, 3.55, 4.05, 4.55, 5.05, 8.05, 10.05)
df_ad_results_formI = apply_adaptive_scaling_mc_range_r0(list_r0, sigma, folder_dir_ad)
df_ad_results_formI
setwd("~/GitHub/epidemic_modelling")
folder_dir_ad = 'Results/Adaptive_scaling_MCMC/adaptive_mcmc_iter_I'
list_r0 = c(0.7, 0.8, 0.9, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0)  #c(0.8, 0.9, 1.0, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0) #c(0.8, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5,
#list_r0 = c(0.5, 0.65, 0.70, 0.75, 0.8, 0.85, 0.95, 1.05, 2.80, 3.05, 3.55, 4.05, 4.55, 5.05, 8.05, 10.05)
df_ad_results_formI = apply_adaptive_scaling_mc_range_r0(list_r0, sigma, folder_dir_ad)
df_ad_results_formI
folder_dir_ad = 'Results/Adaptive_scaling_MCMC/adaptive_mcmc_iter_I'
#list_r0 = c(0.5, 0.65, 0.70, 0.75, 0.8, 0.85, 0.95, 1.05, 2.80, 3.05, 3.55, 4.05, 4.55, 5.05, 8.05, 10.05)
df_ad_results_formI = apply_adaptive_scaling_mc_range_r0(list_r0, sigma, folder_dir_ad)
adaptive_scaling_metropolis_r0 <- function(data, n, sigma, alpha_star, x0 = 1, burn_in = 5000) { #burn_in = 2500
'Adaptive scaling Metropolis algorithm (adpoted from Vihola (2011)
Returns mcmc samples of R0 & acceptance rate'
#Set up
r0_vec <- vector('numeric', n)
scaling_vec <- vector('numeric', n)
r0_vec[1] <- x0
scaling_vec[1] <- x0
U <- runif(n)
count_accept = 0
count_reject = 0
#MCMC chain
for(i in 2:n) {
#New Proposal
Y <- r0_vec[i-1] + exp(scaling_vec[i-1])*rnorm(1)
sigma = exp(scaling_vec[i-1])*rnorm(1)
if(Y < 0){
Y = abs(Y)
}
log_alpha = log_likeII(data, Y) - log_likeII(data, r0_vec[i-1]) + dgamma(Y, shape = 1, scale = 1, log = TRUE) - dgamma(r0_vec[i-1], shape = 1, scale = 1, log = TRUE) #log_prior(theta_dash) - log_prior(theta) = 1 - 1
if(log(U[i]) < log_alpha) {
r0_vec[i] <- Y
count_accept = count_accept + 1
} else {
r0_vec[i] <- r0_vec[i-1]
count_reject = count_reject + 1
}
log_alpha = min(0, log_alpha)
#Scaling factor
scaling_vec[i] = scaling_vec[i-1] + (1/i)*(exp(log_alpha) - alpha_star)
}
#Final stats
total_iters = count_accept + count_reject
accept_rate = 100*(count_accept/(count_accept+count_reject))
num_samples = count_accept
print("Total iterations = ")
print(total_iters)
print("Acceptance rate = ")
print(accept_rate)
print("Number samples = ")
print(count_accept)
#Burn-in
r0_vec = r0_vec[burn_in:n]
#Return r0, acceptance rate
return(list(r0_vec, accept_rate, num_samples, sigma))
}
apply_adaptive_scaling_mc_range_r0 <- function(list_r0, sigma, folder_dir_ad){
#Create folder
ifelse(!dir.exists(file.path(folder_dir_ad)), dir.create(file.path(folder_dir_ad)), FALSE)
list_accept_rate = vector('numeric', length(list_r0))
list_sd = vector('numeric', length(list_r0))
list_num_samp = vector('numeric', length(list_r0))
list_time_taken = vector('numeric', length(list_r0))
i = 1
for (r0X in list_r0){
#Get simulated data when r0 is r0X
print(r0X)
data = simulate_branching(num_days, r0X, shape_gamma, scale_gamma)
#Time
start_time = Sys.time()
mcmc_params_ad = adaptive_scaling_metropolis_r0(data, n, sigma, alpha_star)
end_time = Sys.time()
time_elap = end_time - start_time
print('Time elapsed:')
print(time_elap)
#Extract params
r0_mcmc = mcmc_params_ad[1]
r0_mcmc = unlist(r0_mcmc)
accept_rate = mcmc_params_ad[[2]]
list_accept_rate[i] = round(accept_rate, 2)
num_samples = mcmc_params_ad[[3]]
list_num_samp[i] = num_samples
sd_final = mcmc_params_ad[[4]]
list_sd[i] = round(sd_final, 3)
list_time_taken[i] = round(time_elap, 2)
i = i + 1
#Apply Plotting
mcmc_plotting_adaptive(r0_mcmc, r0X, folder_dir_ad)
}
#Create dataframe
df_results <- data.frame(
r0 = list_r0,
accept_rate = unlist(list_accept_rate),
n_samples = unlist(list_num_samp),
time_sec = unlist(list_time_taken),
sd_final = unlist(list_sd))
print(df_results)
df_results
}
#Apply
sigma = 0.75
folder_dir_ad = 'Results/Adaptive_scaling_MCMC/adaptive_mcmc_iter_I'
list_r0 = c(0.7, 0.8, 0.9, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0)  #c(0.8, 0.9, 1.0, 2.75, 3, 3.5, 4.0, 4.5, 5.0, 8.0, 10.0) #c(0.8, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5,
#list_r0 = c(0.5, 0.65, 0.70, 0.75, 0.8, 0.85, 0.95, 1.05, 2.80, 3.05, 3.55, 4.05, 4.55, 5.05, 8.05, 10.05)
df_ad_results_formI = apply_adaptive_scaling_mc_range_r0(list_r0, sigma, folder_dir_ad)
df_ad_results_formI
#*******************************************************
#Super-spreading simulation
simulation_super_spreaders = function(num_days, shape_gamma, scale_gamma, aX, bX, ss_mult) {
'Simulate an epidemic with Superspreading events
prop_ss = Proportion of superspreading days
magnitude_ss = increased rate of superspreading event'
#Set up
total_infecteds = vector('numeric', num_days)
nss_infecteds = vector('numeric', num_days)
ss_infecteds = vector('numeric', num_days)
total_infecteds[1] = 2
nss_infecteds[1] = 2
ss_infecteds[1] = 0
#Infectiousness (Discrete gamma) - I.e 'Infectiousness Pressure' - Sum of all people
#Explanation: Gamma is a continuous function so integrate over the density at that point in time (today - previous day)
prob_infect = pgamma(c(1:num_days), shape = shape_gamma, scale = scale_gamma) - pgamma(c(0:(num_days-1)), shape = shape_gamma, scale = scale_gamma)
#Days of Infection Spreading
for (t in 2:num_days) {
#Regular infecteds (tot_rate = lambda) fix notation
lambda_t = sum((nss_infecteds[1:(t-1)] + ss_mult*ss_infecteds[1:(t-1)])*rev(prob_infect[1:(t-1)])) #?Why is it the reversed probability - given the way prob_infect is written. Product of infecteds & their probablilty of infection along the gamma dist at that point in time
nss_infecteds[t] = rpois(1, aX*lambda_t) #Assuming number of cases each day follows a poisson distribution. Causes jumps in data
ss_infecteds[t] = rpois(1, bX*lambda_t)
total_infecteds[t] = nss_infecteds[t] + ss_infecteds[t]
}
total_infecteds
}
#Apply
n = 50000
num_days = 15 #60 #100
shape_gamma = 6
scale_gamma = 1
aX = 2
bX = 2
ss_mult = 5
data_ss = simulation_super_spreaders(num_days, shape_gamma, scale_gamma, aX, bX, ss_mult)
#Plot
plot.ts(data_ss)
#Plot
plot.ts(data_ss)
